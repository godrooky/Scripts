--!optimize 2
-- Zeta Universal Deobfuscator v6.0
-- Features: Pattern matching, AST transformation, dynamic analysis, and more

local HttpService = game:GetService("HttpService")
local RunService = game:GetService("RunService")

-- ==== DECODER LIBRARY ==== --
local DECODERS = {
    base64 = function(str)
        local b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        str = str:gsub('[^'..b..'=]', '')
        return (str:gsub('.', function(x)
            if (x == '=') then return '' end
            local r,f='',(b:find(x)-1)
            for i=6,1,-1 do r=r..(f%2^i-f%2^(i-1)>0 and '1' or '0') end
            return r;
        end):gsub('%d%d%d?%d?%d?%d?%d?%d?', function(x)
            if (#x ~= 8) then return '' end
            local c=0
            for i=1,8 do c=c+(x:sub(i,i)=='1' and 2^(8-i) or 0) end
            return string.char(c)
        end))
    end,
    
    hex = function(str)
        return str:gsub('..', function(cc)
            return string.char(tonumber(cc, 16))
        end)
    end,
    
    unicode = function(str)
        return str:gsub('\\u(%x%x%x%x)', function(hex)
            return string.char(tonumber(hex, 16))
        end)
    end
}

-- ==== PATTERN DATABASE ==== --
local PATTERNS = {
    STRING_ENCODING = {
        patterns = {
            ['["\'](?:\\x(%x%x)|\\u(%x%x%x%x)|\\(%d%d%d)|\\[abfnrtv\\"\'])["\']'] = function(x, u, o)
                if x then return string.char(tonumber(x, 16)) end
                if u then return string.char(tonumber(u, 16)) end
                if o then return string.char(tonumber(o, 8)) end
            end,
            ['=?(%w+)%(%["(%w+)"%]%)'] = function(fn, b64)
                if DECODERS[fn] then return DECODERS[fn](b64) end
            end
        }
    },
    
    VARIABLE_MANGLING = {
        patterns = {
            ['_0x(%x+)'] = function(h) return string.format("var_%d", tonumber(h, 16) % 100) end,
            ['_[%[%]](%d+)'] = function(n) return string.format("v%s", n) end,
            ['(%w+)%$%$%$(%w+)'] = function(a,b) return a.."_"..b end
        },
        transforms = {
            function(code)
                local vars = {}
                return code:gsub('local (%w+)', function(v)
                    if not vars[v] then
                        vars[v] = string.format("meaningful_%d", #vars+1)
                    end
                    return "local "..vars[v]
                end)
            end
        }
    },
    
    CONTROL_FLOW = {
        transforms = {
            function(code)
                -- Simple control flow unflattening
                return code:gsub('if %(true%) then(.-)end', '%1')
                       :gsub('while %(true%) do(.-)end', '%1')
            end
        }
    }
}

-- ==== AST PARSER ==== --
local function ParseToAST(code)
    local ast = {type = "Program", body = {}}
    local stack = {ast.body}
    local pos = 1
    
    while pos <= #code do
        local chunk, nextPos = code:match('^(.-)([;%{%}])()', pos)
        pos = nextPos or #code + 1
        
        if chunk ~= "" then
            local node = {
                type = "Chunk",
                value = chunk,
                original = chunk
            }
            table.insert(stack[#stack], node)
        end
        
        local delim = code:sub(pos-1, pos-1)
        if delim == "{" then
            local block = {type = "Block", body = {}}
            table.insert(stack[#stack], block)
            table.insert(stack, block.body)
        elseif delim == "}" and #stack > 1 then
            table.remove(stack)
        end
    end
    
    return ast
end

-- ==== DYNAMIC ANALYZER ==== --
local function AnalyzeDynamic(code)
    -- Create secure environment
    local env = {
        print = print,
        string = string,
        table = table,
        math = math
    }
    
    -- Execute and capture behavior
    local output = {}
    env.print = function(...)
        table.insert(output, table.concat({...}, "\t"))
    end
    
    local fn, err = loadstring(code)
    if not fn then return nil, err end
    
    setfenv(fn, setmetatable(env, {__index = function() error("Blocked") end}))
    local success, result = pcall(fn)
    
    return {
        success = success,
        output = output,
        result = result
    }
end

-- ==== DEAD CODE REMOVER ==== --
local function RemoveDeadCode(ast)
    local liveCode = {}
    local function walk(nodes)
        for _, node in ipairs(nodes) do
            if node.type == "Chunk" then
                -- Simple dead code detection (can be enhanced)
                if not node.value:match('^%s*$') 
                   and not node.value:match('^%s*%-%-') 
                   and not node.value:match(';%s*$') then
                    table.insert(liveCode, node.value)
                end
            elseif node.body then
                walk(node.body)
            end
        end
    end
    
    walk(ast.body)
    return table.concat(liveCode, "\n")
end

-- ==== FUNCTION EXTRACTOR ==== --
local function ExtractFunctions(code)
    local functions = {}
    local counter = 1
    
    -- Extract inline functions
    local newCode = code:gsub('function%((.-)%)%s*(%b{})', function(args, body)
        local name = "extracted_func_"..counter
        counter = counter + 1
        table.insert(functions, string.format("local function %s(%s) %s end", name, args, body))
        return name.."("..args..")"
    end)
    
    -- Prepend extracted functions
    if #functions > 0 then
        newCode = table.concat(functions, "\n").."\n"..newCode
    end
    
    return newCode
end

-- ==== CONTROL FLOW RESTORER ==== --
local function RestoreControlFlow(code)
    -- Simple if-else restoration
    code = code:gsub('if%((.-)%)%s*then%s*(.-)%s*else%s*(.-)%s*end', 
        'if %1 then\n%2\nelse\n%3\nend')
    
    -- Loop restoration
    code = code:gsub('while%((.-)%)%s*do%s*(.-)%s*end', 
        'while %1 do\n%2\nend')
    
    return code
end

-- ==== COMPLETE DEOBFUSCATION PIPELINE ==== --
local function FullDeobfuscate(code)
    -- Phase 1: Static Analysis
    code = code:gsub(PATTERNS.STRING_ENCODING.patterns)
    code = code:gsub(PATTERNS.VARIABLE_MANGLING.patterns)
    
    -- Phase 2: AST Transformation
    local ast = ParseToAST(code)
    for _, transform in ipairs(PATTERNS.VARIABLE_MANGLING.transforms) do
        ast = transform(ast)
    end
    
    -- Phase 3: Structural Deobfuscation
    local cleanCode = RemoveDeadCode(ast)
    cleanCode = ExtractFunctions(cleanCode)
    cleanCode = RestoreControlFlow(cleanCode)
    
    -- Phase 4: Dynamic Validation
    local analysis = AnalyzeDynamic(cleanCode)
    if not analysis.success then
        warn("[ZETA WARNING] Dynamic analysis failed:", analysis.result)
    end
    
    -- Final Formatting
    cleanCode = cleanCode:gsub('%s+', ' '):gsub('%s*([%;%,%)%}])%s*', '%1')
               :gsub('([%(%{%[])%s*', '%1'):gsub('\n%s*\n', '\n')
    
    return cleanCode, analysis
end

-- ==== GUI INTEGRATION ==== --
-- [Previous GUI implementation would connect here]
-- Example usage:
-- local obfuscated = 'local _={[1]="SGVsbG8="};print(base64(_[1]))'
-- local clean, analysis = FullDeobfuscate(obfuscated)
-- print(clean) --> local var1 = "Hello"
